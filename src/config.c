/*
 * config.c - APme: Aion Automatic Abyss Point Tracker
 *
 * Copyright (C) 2012 Mitja Horvat <pinkfluid@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

/**
 * @file
 * Configuration related functions
 * 
 * @author Mitja Horvat <pinkfluid@gmail.com>
 */
#include <stdbool.h>
#include <stdint.h>
#include <errno.h>

#include "iniparser.h"
#include "config.h"
#include "util.h"
#include "console.h"
#include "aion.h"
#include "version.h"

/**
 * @defgroup config Configuration Management
 *
 * @{
 */

/** The configuration database */
static dictionary *cfg_db = NULL;
/** Timestamp of the last poll */
static uint64_t cfg_timestamp = 0;

/*
 * Static functions
 */
static bool cfg_ini_path(char *inifile, size_t inifile_sz);
static void cfg_set_dirty(void);

/**
 * Initialize the configuration sub-system
 */
bool cfg_init(void)
{
    return cfg_load();
}

/**
 * Load the configuration from the default INI file and initialize the global 
 * variables 
 *
 * @retval      true        If configuration successfully loaded
 * @retval      false       If there was an error loading the configuration
 */
bool cfg_load(void)
{
    char *ini_sections[] = { CFG_SEC_APP };
    char inifile[UTIL_MAX_PATH];

    if (cfg_db != NULL)
    {
        con_printf("CFG: Configuration already loaded, reloading\n");
        iniparser_freedict(cfg_db);
        cfg_db = NULL;
    }

    con_printf("CFG: Loading configuration.\n");

    if (!cfg_ini_path(inifile, sizeof(inifile)))
    {
        con_printf("CFG: cfg_load() was unable to deterimine the inifile path\n");
    }

    cfg_db = iniparser_load(inifile);
    if (cfg_db == NULL)
    {
        con_printf("CFG: iniparser_load() failed on '%s'\n", inifile);
        return false;
    }

    /*
     * XXX: Iniparser is really dumb -- it does not create the section automatically
     * if it does not exist.
     */
    unsigned int ii;

    for (ii = 0; ii < sizeof(ini_sections) / sizeof(ini_sections[0]); ii++)
    {
        if (iniparser_find_entry(cfg_db, ini_sections[ii]) == 0)
        {
            con_printf("CFG: Creating section: %s\n", ini_sections[ii]);
            iniparser_set(cfg_db, ini_sections[ii], NULL);
        }
    }

    con_printf("CFG: Configuration loaded successfully.\n");

    return true;
}

/**
 * Save the current run-time configuration to the config file
 *
 * @note If the configuration was not previously loaded with cfg_load(),
 * nothing will be written.
 *
 * @retval          true    If the configuration was saved successfully
 * @retval          false   If the configuration was not saved
 */
bool cfg_store(void)
{
    char inifile[UTIL_MAX_PATH];
    FILE *fini;

    if (cfg_db == NULL)
    {
        con_printf("CFG: Unable to store the configuration since no configuration was loaded.\n");
        return false;
    }

    if (!cfg_ini_path(inifile, sizeof(inifile)))
    {
        con_printf("CFG: cfg_store() was unable to deterimine the inifile path\n");
        return false;
    }

    con_printf("CFG: Saving configuration to '%s'\n", inifile);
    fini = fopen(inifile, "w");
    if (fini == NULL)
    {
        con_printf("CFG: Error opening '%s' for writing. Not saving configuration.\n", inifile);
        return false;
    }

    fprintf(fini, "; This file was autogenerated by APme %s -- edit at your own risk.\n", APME_VERSION_STRING);
    fprintf(fini, "; Any modifications to this file will be overwritten by the next configuration save.\n");

    con_printf("CFG: Dumping the INI file.\n");
    iniparser_dump_ini(cfg_db, fini);

    fclose(fini);

    return true;
}


/**
 * Mark the current configuration as dirty. Refresh the timestamp, so we delay the write
 * a bit.
 */
void cfg_set_dirty(void)
{
    cfg_timestamp = sys_monotime();
    con_printf("CFG: Configuration marked dirty at %llu\n", cfg_timestamp);
}

/**
 * Check the cfg_db status periodically. If it is dirty, and more than 1000ms
 * elapsed since the last update, write the configuration to disk.
 */
void cfg_periodic(void)
{

    if (cfg_timestamp == 0)
    {
        return;
    }

    if ((sys_monotime() - cfg_timestamp) < 1000) return;

    con_printf("CFG: Periodic is saving configuration, last timestamp %llu.\n", cfg_timestamp);

    if (!cfg_store())
    {
        con_printf("Error saving configuration.\n");
    }

    /* Mark the configuration clean */
    cfg_timestamp = 0;
}

/**
 * Set a the configuration parameter @p name in section @p section
 * to the value @p value
 *
 * @note This function will not update the configuration file, use @ref cfg_store()
 * to update it.
 *
 * @param[in]       secition    The parameter section
 * @param[in]       name        Parameter name
 * @param[in]       value       Parameter value
 *
 * @retval          true        On success
 * @retval          false       On errror
 */
bool cfg_set_string(char *section, char *name, char *value)
{
    char key[CFG_KEYSZ];

    con_printf("CFG: Storing string %s:%s -> %s\n", section, name, value);

    if (cfg_db == NULL)
    {
        con_printf("CFG: No configuration loaded.\n");
        return false;
    }

    key[0] = '\0';
    util_strlcat(key, section, sizeof(key));
    util_strlcat(key, ":", sizeof(key));
    util_strlcat(key, name, sizeof(key));

    if (iniparser_set(cfg_db, key, value) != 0)
    {
        con_printf("CFG: iniparser_set() failed\n");
        return false;
    }

    /* Mark the configuration dirty -- needs to be saved */
    cfg_set_dirty();

    return true;
}

/**
 * Set a the configuration parameter @p name in section @p section
 * to the value @p value
 *
 * @note This function will not update the configuration file, use @ref cfg_store()
 * to update it.
 *
 * @param[in]       secition    The parameter section
 * @param[in]       name        Parameter name
 * @param[in]       value       Parameter value
 *
 * @retval          true        On success
 * @retval          false       On errror
 */
bool cfg_set_int(char *section, char *name, int value)
{
    char strval[64];

    con_printf("CFG: Storing int %s:%s -> %d\n", section, name, value);
    snprintf(strval, sizeof(strval), "%d", value);

    return cfg_set_string(section, name, strval);
}

/**
 * Retrieve a string from the configuration run-time configuration database
 *
 * @param[in]       section     The configuration section
 * @param[in]       name        The parameter name
 * @param[out]      value       The buffer that will receive the parameter value
 * @param[in]       valuesz     Maximum size of @p value
 *
 * @retval          true        On success
 * @retval          false       On error
 */
bool cfg_get_string(char *section, char *name, char *value, size_t valuesz)
{
    char key[CFG_KEYSZ];
    char *kval;

    con_printf("CFG: Looking up %s:%s\n", section, name);

    if (cfg_db == NULL)
    {
        con_printf("CFG: Configuration not loaded.\n");
        return false;
    }

    key[0] = '\0';
    util_strlcat(key, section, sizeof(key));
    util_strlcat(key, ":", sizeof(key));
    util_strlcat(key, name, sizeof(key));

    kval = iniparser_getstring(cfg_db, key, NULL);
    if (kval == NULL)
    {
        con_printf("CFG: Key not found\n");
        return false;
    }

    con_printf("CFG: Key '%s' -> '%s'\n", key, kval);

    util_strlcpy(value, kval, valuesz);

    return true;
}

/**
 * Get the location of the INI file, create it if it does not exist
 *
 * @param[out]          inifile     Path to the configuration INI file
 * @param[in]           inifile_sz  Maximum number of bytes available in @p inifile
 *
 * @retval              true        On success
 * @retval              false       On erorr
 */
bool cfg_ini_path(char *inifile, size_t inifile_sz)
{
    FILE *fini;

    if (!sys_appdata_path(inifile, inifile_sz))
    {
        con_printf("CFG: cfg_load() was unable to retrieve the config data\n");
        return false;
    }

    /* Append the apme */
    util_strlcat(inifile, "/", inifile_sz);
    util_strlcat(inifile, CFG_APME_INI, inifile_sz);

    con_printf("CFG: INI file path: %s\n", inifile);

    /* Create the file if it does not exist */
    fini = fopen(inifile, "a+");
    if (fini == NULL)
    {
        con_printf("CFG: Unable to create the ini file: %s\n", strerror(errno));
        return false;
    }
    fclose(fini);

    return true;
}

/**
 * @}
 */
